%%%
%% Development :: Solvers
%%%
\section{Solvers}
\label{sec:solvers}

A Feasibility Study was created to attempt to predict the difficulty of specific
clue types and their regularity in cryptic crosswords. All seventeen clues types
were analysed in order to plan which would be implemented in each iteration of
the implementation process. The first iteration involved Hidden, Anagram,
Acrostic and Pattern as they all had a low difficulty. The next iteration
involved Homophones, Palindromes, Double Definition and Spoonerisms to step up
the difficulty of the algorithms. Finally, the last solvers to be implemented
were Charades, Deletions, Containers and Reversals as they were seen as the most
beneficial to implement in the time left for the project.

Therefore, with the additional reason of a time limit,  Purely Cryptic and \&
lit clue types were not implemented due to their high difficulty and
Substitutions, Shifting and Exchange clue types were not implemented due to
their rarity.

%%%%
%% Implementation :: Solvers :: Hidden
%%%
\subsection{Hidden}

When investigating the Hidden clue type, it was found that the answer to the
clue would be within the clue itself. For example:

Creamy cheese used in apricot tart.

 
Answer: RICOTTA

In the clue above the answer `ricotta' is hidden within the two words `apricot
tart'. The algorithm takes the clue as a whole, without spaces, and then uses
the substring method  within Java to find all possible hidden words (as the
Hidden clue type can also hide words in reverse, the clue is also passed in
reverse). It does this by taking the index of the for loop and length of the
solution as boundaries.

Listing \ref{hiddenSnippet} illustrates how all possible solutions are found 
(without additional solution trace functionality):

\begin{lstlisting}[caption={INSERT CAPTION},
                   label=hiddenSnippet] 
 int index;
 for (index = 0; index <= limit; index++) {
	Solution s = new Solution(clue.substring(index, index + totalLength), NAME);
	solutions.add(s);
 }
\end{lstlisting}

For the above clue, where limit is equal to seven because `ricotta' is seven
letters  long, the first five iterations will add the following solutions to the
list; `creamyc',  `reamych', `eamyche', `amychee', `mychees'. Eventually, the
loop will pick up  `ricotta' and add it to the solution list. From the output
gained in the first five  iterations it is apparent that a lot of invalid
solutions are added to the list, therefore a number of steps are also
implemented to eliminate invalid solutions.

Once all possible solutions have been found, they are all checked to make sure
they are not words from the original clue. For example, `apricot' is seven
letters long and will  have been picked up through the algorithm, however it is
not a hidden word and therefore  not a valid solution.

Next, the solutions are checked against the pattern provided. This means if the
user  has input known letters or there are spaces in the end solution but the
solution being  checked does not match these requirements, these solutions are
removed.

Finally, all solutions are checked against the dictionary to determine whether
they  are valid words. The solutions that are left are then returned to the
user.

%%%%
%% Implementation :: Solvers :: Anagram
%%%
\subsection{Anagram}

%%%%
%% Implementation :: Solvers :: Acrostic
%%%
\subsection{Acrostic}

The Acrostic clue type is another of the types which have the end solution
placed within  the clue itself which can be seen in the following clue:

What's seen at start of any road running one way?

Answer: ARROW

The answer to the above clue can be found by taking the first letter from each
word in  the phrase `any road running one way'. The algorithm splits the clue
into an array of words  to allow each word to be looked at individually. For
each word, the first letter is taken using the substring method in Java. The 
first letter of each word is stored in a string to use the substring method 
once again to search through possible solutions within the string.

To find the possible solutions from the string, it is done within a loop with the same number 
of iterations as the length of the end solution. This means the loop will pick up the 
following possible solutions for the above clue; `wsaso', `sasoa', `asoar', 
`soarr', `oarro', `arrow'.

As with previous algorithms (e.g. Hidden), this method adds various 
invalid potential solutions into the list. To eliminate invalid solutions, the 
potential solutions are run through the dictionary to determine whether 
they are valid English words. Finally, the potential solutions will be run through 
the pattern given by the user and the solution itself to ensure the 
requirements for the end solution match up. Once all this has been completed, 
the results are returned to the user. 

%%%%
%% Implementation :: Solvers :: Pattern
%%%
\subsection{Pattern}

%%%%
%% Implementation :: Solvers :: Homophone
%%%
\subsection{Homophone}

%%%%
%% Implementation :: Solvers :: Palindrome
%%%
\subsection{Palindrome}

The Palindrome clue type gets it's end solution by taking a word from 
the clue itself and taking a synonym from it. This synonym must be 
spelt the same whether the word is reversed or in it's normal state. 
An example of a palindrome is `noon' because when the word is reversed 
it still retains it's original spelling. Below is an example Palindrome clue:

Look both ways

Answer: PEEP

As with `noon', `peep' can be reversed and still retains it's original spelling. 

The algorithm for the Palindrome clue type first takes each word 
from the clue and places them into a list. Each word is then run through 
the thesaurus to find their synonyms. Once this has been completed a 
filtering mechanism is needed to find all synonyms which follow the 
rules of palindromes. 

Listing \ref{hiddenSnippet} illustrates how all the synonyms that have
 been found are filtered by the algorithm: 

\begin{lstlisting}[caption={INSERT CAPTION},
                   label=hiddenSnippet] 
 private void filterNonePalindromes(Collection<String> solutions) {
	for (Iterator<String> it = solutions.iterator(); it.hasNext();) {
		String normal = WordUtils.removeSpacesAndHyphens(it.next());
		String reverse = new StringBuilder(normal).reverse().toString();

		// If the word isn't "symmetrical" from both sides, remove it
		if (!normal.equals(reverse)) {
			it.remove();
		}
	}
 }
\end{lstlisting}

The method to remove synonyms that are not palindromes uses an 
iterator to loop through each one. For each one, spaces and hyphens 
are removed to make the comparison possible. This step is essential for 
palindromes such as `put up' because with the space present the 
algorithm would not see `pu tup' as equal. Once all punctuation and
spaces have been removed from the synonym, the alogorithm then 
uses the reverse method within Java to retrieve the reversed synonym. 
For example, if the word `cryptic' was passed to the reverse method 
it would return `citpyrc'. This means when the normal word `cryptic' 
and the reverse word `citpyrc' are passed to the if statement to check 
whether they were equal, it would be false and therefore the synonym 
`cryptic' would be removed as a potential solution.

Once the synonyms have been filtered, the algorithm then does further 
filtering to make sure the potential solutions fit the pattern and known 
letters of the end solution. When the filtering has taken place, the 
potential solutions are passed to the user.

%%%%
%% Implementation :: Solvers :: Double Defintion
%%%
\subsection{Double Defintion}

The solution for a Double Defintion clue comes from taking two 
words within the clue that could be the definition of the solution. 
For example:

Car plant

Answer: LOTUS

A `lotus' can be either a type of car or a type of plant, hence 
why the clue is of type Double Definition. 

To explain the algorithm for this clue type it is necessary to 
also explain the functionality that comes with using the thesaurus. 
The thesaurus used for the project is a text file where each line starts
 with a word. Each of the following words on that line are synonyms of 
the first word. From implementing the solvers different ways to access 
synonyms were found, these different methods provide a range of 
results which vary from vague to limited synoynms being found.
 The Double Definition algorithm uses two of these methods, one 
which takes a clue word and finds it in the thesaurus where it is the 
first word and adds all the synonyms to a list, this method can be known 
as getting `first level synonyms'. The second method does not only look 
for the clue word as the first word of a row, it looks 
for the clue word in any position in any row in the thesaurus, therefore 
returning a wider range of results. This second method can be known as
getting `second level synoynms'.

The algorithm itself first splits the clue into an array so each word 
can be looked at individually. For each word in the clue, both the 
methods explained above are used. This means two maps are created,
 one which contains the clue word along with it's first level synonyms 
and a second which also contains the clue word but along with it's 
second level synoynms. 

Now the algorithm compares each of these maps to find different words 
in the clue with the same synonym. This is firstly done by comparing 
each word and it's synonyms for the first level synonyms. Next, it is done 
by comparing first level synonyms with second level synonyms. If it occurs,
 the synonym that has been found for two words in the clue, the potential 
solution is added to a list. As the thesaurus methods check for invalid solutions
 (potential solutions which do not match the length of the  end solution etc.), 
once all synonyms have been matched up and checked, the results can 
be returned to the user. 

Second level synonyms are not compared with second level synonyms. 
This is because second level synonyms can be extremely vague so the 
chances of finding a synonym which links to two words in the clue is 
more likely and less likely to be the correct answer. Another reason is 
that the likelihood of this algorithm returning results for a clue that 
is not in fact of Double Definition type is highly more likely if second 
synonyms for one word are compared with second synoyms for 
another. Although, the chances of finding the answer for all double 
defintion clues by comparing two sets of second level synonyms is 
highly beneficial, the downfalls outweigh the benefits and therefore 
that is why this design decision was made. 

%%%%
%% Implementation :: Solvers :: Spoonerism
%%%
\subsection{Spoonerism}

%%%%
%% Implementation :: Solvers :: Charade
%%%
\subsection{Charade}

%%%%
%% Implementation :: Solvers :: Deletion
%%%
\subsection{Deletion}

%%%%
%% Implementation :: Solvers :: Container
%%%
\subsection{Container}

The Container clue type involves putting a word inside another word.
 For example: 

In appearance everyone is lacking in depth

Answer: SHALLOW

With the clue above, the synonym show for `appearance' is found 
and thw synonym for everyone `all' is found. Placing all inside shallow 
gives the solution `shallow'. 

A clue word itself can be put inside or around the outside of another clue 
word or synonym of clue word. Another possibility is a synonym can be 
placed inside or around the outside of another clue word or synonym of 
a clue word. These possibilities make the need for an indicator of which 
possibility it is, necessary. 

For the Container clue type, an indicator file was created which determined 
which word went inside another. The indicators were seperated into two 
lists, one where the indicators mean the word in the left of the clue goes in 
the word in the right of the clue, and the other where the indicators mean 
the word in the right of the clue goes in the word of the left of the clue. 
 

%%%%
%% Implementation :: Solvers :: Reversal
%%%
\subsection{Reversal}

The reversal algorithm is the only algorithm to make some use of the natural 
language processing library (NLP) --- Apache OpenNLP. Although the algorithm 
does not fully use the all capabilities of the NLP it does use it enough to 
ensure that the algorithms are not being over worked.

The algorithm will attempt to get a list of possible fodders that can be used 
throughout the solving process. From a initial review it was clear that the 
majority of the fodders within a reversal clue are a either a singular or plural
noun.

Apache OpenNLP has a number of methods that can tokenise a string, meaning that 
each word in a sentence is aligned to it's type of word. For example if the 
algorithm was given the clue:

Secure weapons turned over (4)

ANSWER: sung (reversal of guns)

Then the only noun (or fodder) that would be returned is weapons. Although the 
algorithm can handle multiple fodders it can not handle the rare clues in which
the answer can not be deduced from a noun.

Listing \ref{obtainFodders} illustrates the simply way in which the algorithm 
utilises Apache OpenNLP's tokenising system to be able to pick out all nouns.

\begin{lstlisting}[caption={Deducing all singular or plural nouns within the clue},
                   label=obtainFodders]  
for (int i = 0; i < tags.length; i++) {
  // Obtain words that are a singular or plural noun
  if (tags[i].equals("NN") || tags[i].equals("NNS")) {
    fodders.add(words[i]);
  }
}
\end{lstlisting}

Once a list of fodders have been computed each of the fodders will have their
synonyms computed and reversed. If the newly generated `word' can be found in 
the dictionary, and can be matched to the given patter then it is marked as a 
potential solution.

Listing \ref{reversalAlgorthim} indicates the simplicity of the algorithm and 
allows for an efficient approach to solving the clue.

\begin{lstlisting}[caption={Core reversal algorthim deducing possbile solutions},
                   label=reversalAlgorthim]  
// Get all synonyms that match the reversed pattern
Set<String> synonyms = THESAURUS.getSecondSynonyms(fodder, pattern, true);
// Reverse all synonyms to try to create another word
for (String synonym : synonyms) {
  // Reverse the synonym
  String reversedWord = WordUtils.reverseWord(synonym);
  // Add as a solution if the reversed word is a real word
  if (DICTIONARY.isWord(reversedWord)) {
      // Add the solution to all possible solutions
      collection.add(new Solution(reversedWord, NAME));
  }
}
\end{lstlisting}

However it must be stated that the algorithm (as with all other algorithms) does
not have any understanding of the words it generates. For example it is unaware
that Alpha and Beta are both types of characters. This can cause many issues for
the reversal algorithm as it is depended upon additional/external `knowledge'.
