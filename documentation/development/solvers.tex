%%%
%% Development :: Solvers
%%%
\section{Solvers}
\label{sec:solvers}

A Feasibility Study was created to attempt to predict the difficulty of specific
clue types and their regularity in cryptic crosswords. All seventeen clues types
were analysed in order to plan which would be implemented in each iteration of
the implementation process. The first iteration involved Hidden, Anagram,
Acrostic and Pattern as they all had a low difficulty. The next iteration
involved Homophones, Palindromes, Double Definition and Spoonerisms to step up
the difficulty of the algorithms. Finally, the last solvers to be implemented
were Charades, Deletions, Containers and Reversals as they were seen as the most
beneficial to implement in the time left for the project.

Therefore, with the additional reason of a time limit,  Purely Cryptic and \&
lit clue types were not implemented due to their high difficulty and
Substitutions, Shifting and Exchange clue types were not implemented due to
their rarity.

%%%%
%% Implementation :: Solvers :: Hidden
%%%
\subsection{Hidden}

When investigating the Hidden clue type, it was found that the answer to the
clue would be within the clue itself. For example:

Creamy cheese used in apricot tart.

 
Answer: RICOTTA

In the clue above the answer `ricotta' is hidden within the two words `apricot
tart'. The algorithm takes the clue as a whole, without spaces, and then uses
the substring method  within Java to find all possible hidden words (as the
Hidden clue type can also hide words in reverse, the clue is also passed in
reverse). It does this by taking the index of the for loop and length of the
solution as boundaries.

Listing \ref{hiddenSnippet} illustrates how all possible solutions are found 
(without additional solution trace functionality):

\begin{lstlisting}[caption={INSERT CAPTION},
                   label=hiddenSnippet] 
 int index;
 for (index = 0; index <= limit; index++) {
	Solution s = new Solution(clue.substring(index, index + totalLength), NAME);
	solutions.add(s);
 }
\end{lstlisting}

For the above clue, where limit is equal to seven because `ricotta' is seven
letters  long, the first five iterations will add the following solutions to the
list; `creamyc',  `reamych', `eamyche', `amychee', `mychees'. Eventually, the
loop will pick up  `ricotta' and add it to the solution list. From the output
gained in the first five  iterations it is apparent that a lot of invalid
solutions are added to the list, therefore a number of steps are also
implemented to eliminate invalid solutions.

Once all possible solutions have been found, they are all checked to make sure
they are not words from the original clue. For example, `apricot' is seven
letters long and will  have been picked up through the algorithm, however it is
not a hidden word and therefore  not a valid solution.

Next, the solutions are checked against the pattern provided. This means if the
user  has input known letters or there are spaces in the end solution but the
solution being  checked does not match these requirements, these solutions are
removed.

Finally, all solutions are checked against the dictionary to determine whether
they  are valid words. The solutions that are left are then returned to the
user.

%%%%
%% Implementation :: Solvers :: Anagram
%%%
\subsection{Anagram}

%%%%
%% Implementation :: Solvers :: Acrostic
%%%
\subsection{Acrostic}

The Acrostic clue type is another of the types which have the end solution
placed within  the clue itself which can be seen in the following clue:

What's seen at start of any road running one way?

Answer: ARROW

The answer to the above clue can be found by taking the first letter from each
word in  the phrase `any road running one way'. The algorithm splits the clue
into an array of words  to allow each word to be looked at individually. For
each word, the first letter is taken using the substring method in Java. The 
first letter of each word is stored in a string to use the substring method 
once again to search through possible solutions within the string.

To find the possible solutions from the string, it is done within a loop with the same number 
of iterations as the length of the end solution. This means the loop will pick up the 
following possible solutions for the above clue; `wsaso', `sasoa', `asoar', 
`soarr', `oarro', `arrow'.

As with previous algorithms (e.g. Hidden), this method adds various 
invalid potential solutions into the list. To eliminate invalid solutions, the 
potential solutions are run through the dictionary to determine whether 
they are valid English words. Finally, the potential solutions will be run through 
the pattern given by the user and the solution itself to ensure the 
requirements for the end solution match up. Once all this has been completed, 
the results are returned to the user. 

%%%%
%% Implementation :: Solvers :: Pattern
%%%
\subsection{Pattern}

%%%%
%% Implementation :: Solvers :: Homophone
%%%
\subsection{Homophone}

%%%%
%% Implementation :: Solvers :: Palindrome
%%%
\subsection{Palindrome}

The Palindrome clue type gets it's end solution by taking a word from 
the clue itself and taking a synonym from it. This synonym must be 
spelt the same whether the word is reversed or in it's normal state. 
An example of a palindrome is `noon' because when the word is reversed 
it still retains it's original spelling. Below is an example Palindrome clue:

Look both ways

Answer: PEEP

As with `noon', `peep' can be reversed and still retains it's original spelling. 

The algorithm for the Palindrome clue type first takes each word 
from the clue and places them into a list. Each word is then run through 
the thesaurus to find their synonyms. Once this has been completed a 
filtering mechanism is needed to find all synonyms which follow the 
rules of palindromes. 

Listing \ref{hiddenSnippet} illustrates how all the synonyms that have
 been found are filtered by the algorithm: 

\begin{lstlisting}[caption={INSERT CAPTION},
                   label=hiddenSnippet] 
 private void filterNonePalindromes(Collection<String> solutions) {
	for (Iterator<String> it = solutions.iterator(); it.hasNext();) {
		String normal = WordUtils.removeSpacesAndHyphens(it.next());
		String reverse = new StringBuilder(normal).reverse().toString();

		// If the word isn't "symmetrical" from both sides, remove it
		if (!normal.equals(reverse)) {
			it.remove();
		}
	}
 }
\end{lstlisting}

The method to remove synonyms that are not palindromes uses an 
iterator to loop through each one. For each one, spaces and hyphens 
are removed to make the comparison possible. This step is essential for 
palindromes such as `put up' because with the space present the 
algorithm would not see `pu tup' as equal. Once all punctuation and
spaces have been removed from the synonym, the alogorithm then 
uses the reverse method within Java to retrieve the reversed synonym. 
For example, if the word `cryptic' was passed to the reverse method 
it would return `citpyrc'. This means when the normal word `cryptic' 
and the reverse word `citpyrc' are passed to the if statement to check 
whether they were equal, it would be false and therefore the synonym 
`cryptic' would be removed as a potential solution.

Once the synonyms have been filtered, the algorithm then does further 
filtering to make sure the potential solutions fit the pattern and known 
letters of the end solution. When the filtering has taken place, the 
potential solutions are passed to the user.

%%%%
%% Implementation :: Solvers :: Double Defintion
%%%
\subsection{Double Defintion}

%%%%
%% Implementation :: Solvers :: Spoonerism
%%%
\subsection{Spoonerism}

%%%%
%% Implementation :: Solvers :: Charade
%%%
\subsection{Charade}

%%%%
%% Implementation :: Solvers :: Deletion
%%%
\subsection{Deletion}

%%%%
%% Implementation :: Solvers :: Container
%%%
\subsection{Container}

%%%%
%% Implementation :: Solvers :: Reversal
%%%
\subsection{Reversal}

The reversal algorithm is the only algorithm to make some use of the natural 
language processing library (NLP) --- Apache OpenNLP. Although the algorithm 
does not fully use the all capabilities of the NLP it does use it enough to 
ensure that the algorithms are not being over worked.

The algorithm will attempt to get a list of possible fodders that can be used 
throughout the solving process. From a initial review it was clear that the 
majority of the fodders within a reversal clue are a either a singular or plural
noun.

Apache OpenNLP has a number of methods that can tokenise a string, meaning that 
each word in a sentence is aligned to it's type of word. For example if the 
algorithm was given the clue:

Secure weapons turned over (4)

ANSWER: sung (reversal of guns)

Then the only noun (or fodder) that would be returned is weapons. Although the 
algorithm can handle multiple fodders it can not handle the rare clues in which
the answer can not be deduced from a noun.

Listing \ref{obtainFodders} illustrates the simply way in which the algorithm 
utilises Apache OpenNLP's tokenising system to be able to pick out all nouns.

\begin{lstlisting}[caption={Deducing all singular or plural nouns within the clue},
                   label=obtainFodders]  
for (int i = 0; i < tags.length; i++) {
  // Obtain words that are a singular or plural noun
  if (tags[i].equals("NN") || tags[i].equals("NNS")) {
    fodders.add(words[i]);
  }
}
\end{lstlisting}

Once a list of fodders have been computed each of the fodders will have their
synonyms computed and reversed. If the newly generated `word' can be found in 
the dictionary, and can be matched to the given patter then it is marked as a 
potential solution.

Listing \ref{reversalAlgorthim} indicates the simplicity of the algorithm and 
allows for an efficient approach to solving the clue.

\begin{lstlisting}[caption={Core reversal algorthim deducing possbile solutions},
                   label=reversalAlgorthim]  
// Get all synonyms that match the reversed pattern
Set<String> synonyms = THESAURUS.getSecondSynonyms(fodder, pattern, true);
// Reverse all synonyms to try to create another word
for (String synonym : synonyms) {
  // Reverse the synonym
  String reversedWord = WordUtils.reverseWord(synonym);
  // Add as a solution if the reversed word is a real word
  if (DICTIONARY.isWord(reversedWord)) {
      // Add the solution to all possible solutions
      collection.add(new Solution(reversedWord, NAME));
  }
}
\end{lstlisting}

However it must be stated that the algorithm (as with all other algorithms) does
not have any understanding of the words it generates. For example it is unaware
that Alpha and Beta are both types of characters. This can cause many issues for
the reversal algorithm as it is depended upon additional/external `knowledge'.
